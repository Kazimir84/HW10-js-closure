console.log('-----------------------№3');

function sum (x) {    
    return function (y) {
       return x + y;
    };
}

const sum1 = sum(1);
sum1(2); // результат выполнения 3
console.log('sum1', sum1(2));

sum(1)(2); // результат выполнения 3
console.log('sum', sum(1)(2));

console.log('-----------------------№4');

for (let i = 0; i < 10; i++) {   
    setTimeout(function() {
        console.log('i1 = ', i+1);
    }, 0); 
}
// Это получилось, как то автоматически и первое что пришло на ум, в памяти как то зависло что цикл for (начало; условие; шаг), и начало объявляется через let а не var.
// setTimeout - выполняется с задержкой (она ставиться в очередь) и есть вложенная функция
// объявление var выделяет одну "ячейку" в памяти и на эту одну и туже "ячейку" всегда ссылается переменная i.
// объявление let при каждой итерации выделяет новую "ячейку", таким образом переменная i на каждом шаге перебора цикла ссылается на новый адрес.

for (var i = 0; i < 10; i++) {   
    setTimeout(function() {
        console.log('i2 = ', i+1);
    }(), 0); 
}

// setTimeout - выполняется с задержкой (она ставиться в очередь).
// И выполниться тогда, когда цикл пройдет и получит значение 10, и так 10 раз, поэтому и получим значение 10 десять раз.
// А запустив функцию до setTimeout каждому из замыканий создается свое собственное замыкание и i получает свое новое значение которе и выведет setTimeout.

// Даже если сейчас запустить эти две функции одна с let, а вторая с var мы увидим что сначала выполниться с var, а потом с let. Хотя в коде они стоят в обратном порядке. setTimeout(0) ждет пока выполниться все остальное.